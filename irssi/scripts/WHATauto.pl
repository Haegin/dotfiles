#!/bin/perl -w
##### WHATauto - an irssi auto-download script #####
# Version 2.0.3 By mlapaglia & gravey13 (2-19-2010)#
# See http://itsneverlupus.net:81/wordpress for    #
# install/configuration instructions.              #
############## DO NOT EDIT THIS FILE ###############

use strict;
use Irssi::Irc;
use Filesys::Df;
use URI::Escape;
use Net::SMTP::TLS;
use HTML::Entities;
use Config::IniFiles;
use WWW::Mechanize::GZip;
use vars qw($VERSION %IRSSI);

$VERSION="2.0.3";
%IRSSI = (
	authors=> 'mlapaglia & gravey',
	name=> 'WHATauto',
	description=> 'an irssi auto-download script',
	license=> 'GPL',
);

# Irssi settings
Irssi::settings_set_int('cmds_max_at_once', 20);
Irssi::settings_set_int('cmd_queue_speed', 0);

# Log, Credentials, Regex, and Filters data
my (%Reports, %Credentials, %Regex, %Filters, %Setup);
Irssi::print ("**Loading WHATauto Configuration Files**");
loadConfigs();

my $setup = new Config::IniFiles -file => "$ENV{HOME}/.WHATauto/setup.conf", -default => "all";
my $freePercent  = $setup->val('setup', 'freePercent');
my $drive	 = $setup->val('setup', 'drive');
my $cookies 	 = $setup->val('setup', 'cookies');
my $torrentDir	 = $setup->val('setup', 'torrentDir');
my @nickOwner 	 = $setup->val('setup', 'nickOwner');
my @chanFilter	 = $setup->val('setup', 'chanFilter');
Irssi::print ("*setup.conf........ loaded");

# Creating cookies file if it doesn't exist
`touch $cookies`;

# Print script error if any What.CD information is left empty
if (!$torrentDir  || !$cookies || !$drive) {
	Irssi::print (" ");
	Irssi::print ("****************************************");
	Irssi::print ("** ERROR: Required Information Missing!");
	Irssi::print ("** Please provide this information in the configuration.");
	Irssi::print ("** torrent directory: $torrentDir, cookies file: $cookies, drive: $drive");
	Irssi::print ("****************************************");
	Irssi::print (" ");
}

#Check the filters for basic requirements
Irssi::print (" ");
Irssi::print ("**Checking WHATauto Filters**");
foreach my $out (keys %Filters) {
	Irssi::print ("*Checking filter $out");
	if($Filters{$out}{directory} && !(-e $Filters{$out}{directory})) {
		Irssi::print ("** ERROR: Torrent directory $Filters{$out}{directory} does not exist.");
	}
	if(!$Filters{$out}{active}) {
		Irssi::print ("** WARNING: filter \"active\" for $out is either missing or disabled.");
	}
}

###############
#subroutine executes every time a channel is joined
sub channel_joined {
	my @chanlist = @_;
	my $channel = $chanlist[0]->{name};
	my $server = $chanlist[0]->{server};
	chanBlock($channel, $server);
}

###############
#subroutine executes when channel invite is received
sub message_invite {
	my ($server, $channel, $nick, $address) = @_;
	if ($address ~~ @nickOwner) {
		$server->command("JOIN $channel");
	}
}

my %PTPrelease = ();
###############
#subroutine for each private message received
#splitting each message into it's own thread.
sub event_privmsg {
	my ($data, $message, $nick, $address) = @_;
	my ($target, $text) = split(/ :/, $message, 2);
	$text = uri_unescape(decode_entities($text));
	$text =~ s/00,04|00,12|01,15||7||01|02|2|03|04|4|05|5|6|06|7|07|08|8|9|09|10|11|12|13|14|15||||//g;
	tied(%Reports)->WriteConfig("$ENV{HOME}/WHATauto/reports.conf");

	if($target =~ /^$Regex{awesomehd}{channel}$/i && $nick =~ /^$Regex{awesomehd}{botname}$/i && $text =~ m!$Regex{awesomehd}{announce}!) {
		print "*Detected Awesome-HD announce: $1 - $2 - $3 - $4 - $5 - $6 - $7 - $8 - $9 - $10";
		$Reports{awesomehd}{seen}++;
		my %release = (title => $1, year => $2, sceneGroup => $3, quality => $4, container => $5, source => $6);
		my ($scene, $ahdGold, $dxva, $freeleech, $torrentID) = $7, $8, $9, $10, $12;
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'awesomehd' || !$Filters{$out}{active}) {
				next;
			}
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting";
					print "||-----------------------";
					next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) {
					next OUT;
				}
			}
			if($Filters{$out}{scene}) {
				if($scene) {
					print "||02Detected match in scene: $scene";
				} else {
					print "||04Didn't detect match in scene: 08scene not present04, aborting"; next OUT;
				}
			}
			if($Filters{$out}{ahdgold}) {
				if($ahdGold) {
					print "||02Detected match in AHD Gold: $ahdGold";
				} else {
					print "||04Didn't detect match in AHD Gold: 08fastTorrent not present04, aborting"; next OUT;
				}
			}
			if($Filters{$out}{dxva}) {
				if($dxva) {
					print "||02Detected match in DXVA: $dxva";
				} else {
					print "||04Didn't detect match in DXVA: 08DXVA not present04, aborting"; next OUT;
				}
			}
			if($Filters{$out}{freeleech}) {
				if($freeleech) {
					print "||02Detected match in freeleech: $freeleech"; }
				else {
					print "||04Didn't detect match in freeleech: 08freeleech not present04, aborting"; next OUT;
				}
			}
			$Reports{awesomehd}{downloaded}++;
			download($out, $torrentID, $torrentDir, "awesomehd", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{deepbassnine}{channel}$/i && $nick =~ /^$Regex{deepbassnine}{botname}$/i && $text =~ m!$Regex{deepbassnine}{announce}!) {
		print "*Detected DeepBassNine announce: $1 - $2 - $3 - [$4] - $5 - $6 - $7 - $8 - $9 / $10 / $11 / $12 / $13 - $14";
		$Reports{deepbassnine}{seen}++;
	}
	elsif($target =~ /^$Regex{broadcasthenet}{channel}$/i && $nick =~ /^$Regex{broadcasthenet}{botname}$/i && $text =~ m!$Regex{broadcasthenet}{announce}!) {
		my %release = (season => $1, episode => $2, series => $3, year => $4, type => $5, container => $6, encoding => $7, source => $8, uploader => $12);
		my($torrentID, $scene, $fastTorrent) = ($11, $9, $10);
		my $string = "*Detected BroadcasTheNet announce: Series: $3 - Season: $1";
		if($2) {
			$string .= " Episode: $2";
		}
		$string .= " - $4 - $6 / $7 / $8";
		if($scene) {
			$string .= " / Scene";
		}
		if($fastTorrent) {
			$string .= " / FastTorrent";
		}
		print "$string - $12";
		$Reports{broadcasthenet}{seen}++;
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'broadcasthenet' || !$Filters{$out}{active}) { next OUT; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			if($Filters{$out}{scene}) {
				if($scene) {
					print "||02Detected match in scene: $scene";
				} else {
					print "||04Didn't detect match in scene: 08scene not present04, aborting"; next OUT;
				}
			}
			if($Filters{$out}{fastTorrent}) {
				if($fastTorrent) {
					print "||02Detected match in fastTorrent: $fastTorrent";
				} else {
					print "||04Didn't detect match in fastTorrent: 08fastTorrent not present04, aborting"; next OUT;
				}
			}
			$Reports{broadcasthenet}{downloaded}++;
			download($out, $torrentID, $torrentDir, "broadcasthenet", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{torrentleech}{channel}$/i && $nick =~ /^$Regex{torrentleech}{botname}$/i && $text =~ m!$Regex{torrentleech}{announce}!) {
		my %release = (type => $1, title => $2, uploader => $3);
		my $torrentID = $4;
		print "*Detected TorrentLeech announce: $1 - $2 - $3 - $4";
		$Reports{torrentleech}{seen}++;
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'torrentleech' || !$Filters{$out}{active}) { next; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			$Reports{torrentleech}{downloaded}++;
			download($out, $torrentID, $torrentDir, "torrentleech", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{bitmetv}{channel}$/i && $nick =~ /^$Regex{bitmetv}{botname}$/i && $text =~ m!$Regex{bitmetv}{announce}!) {
		my %release = (title => $1, size => $2);
		my $torrentID = $3;
		print "*Detected BitMeTV announce: $1 - $2 - $3";
		$Reports{bitmetv}{seen}++;
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'bitmetv' || !$Filters{$out}{active}) { next; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			$Reports{bitmetv}{downloaded}++;
			download($out, $torrentID, $torrentDir, "bitmetv", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{sceneaccess}{channel}$/i && $nick =~ /^$Regex{sceneaccess}{botname}$/i && $text =~ m!$Regex{sceneaccess}{announce}!) {
		print "*Detected SCC announce: $1 - $2 - $3 - $4 - $5";
		$Reports{sceneaccess}{seen}++;
		my %release = (type => $1, title => $2, pretime => $3, size => $4);
		my $torrentID = $5;
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'sceneaccess' || !$Filters{$out}{active}) { next; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			$Reports{sceneaccess}{downloaded}++;
			download($out, $torrentID, $torrentDir, "sceneaccess", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{pretome}{channel}$/i && $nick =~ /^$Regex{pretome}{botname}$/i && $text =~ m!$Regex{pretome}{announce}!) {
		my %release = (type => $1, format => $2, title => $3, pretime => $4);
		my ($type, $format, $title, $pretime, $torrentID) = ($1, $2, $3, $4);
		print "*Detected PTM announce: $1 - $2 - $3 - $4 - $5";
		$Reports{pretome}{seen}++;
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'pretome' || !$Filters{$out}{active}) { next; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			$Reports{pretome}{downloaded}++;
			download($out, $torrentID, $torrentDir, "pretome", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{digitalhive}{channel}$/i && $nick =~ /^$Regex{digitalhive}{botname}$/i && $text =~ m!$Regex{digitalhive}{announce}!) {
		my %release = (type => $1, title => $2, pretime => $3);
		my $torrentID = $4;
		$Reports{digitalhive}{seen}++;
		print "*Detected DH announce: $1 - $2 - $3 - $4";
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'digitalhive' || !$Filters{$out}{active}) { next; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			$Reports{digitalhive}{downloaded}++;
			download($out, $torrentID, $torrentDir, "digitalhive", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{tehconnection}{channel}$/i && $nick =~ /^$Regex{tehconnection}{botname}$/i && $text =~ m!$Regex{tehconnection}{announce}!) {
		$Reports{tehconnection}{seen}++;
		print "*Detected TC announce: $1 - $2 - $3 - $4 - $5 - $6 - $7 - $8 - $9 - $10";
		my %release = (title => $1, year => $2, codec => $3, quality => $4, container => $5, source => $6, uploader => $8);
		my ($scene, $groupID, $torrentID) = ($7, $9, $10);
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'tehconnection' || !$Filters{$out}{active}) { next OUT; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			if($Filters{$out}{scene} && !$scene) { print "||04Didn't detect match in scene"; next OUT; }
			$Reports{tehconnection}{downloaded}++;
			download($out, $torrentID, $torrentDir, "tehconnection", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{hdbits}{channel}$/i && $nick =~ /^$Regex{hdbits}{botname}$/i && $text =~ m!$Regex{hdbits}{announce}!) {
		my %release = (title => $1, type => $2, uploader => $3);
		my $torrentID = $4;
		print "*Detected HDBits announce: $1 - $2 - $3 - $4";
		$Reports{hdbits}{seen}++;
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'hdbits' || !$Filters{$out}{active}) { next OUT; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			$Reports{hdbits}{downloaded}++;
			download($out, $torrentID, $torrentDir, "hdbits", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{sharetheremote}{channel}$/i && $nick =~ /^$Regex{sharetheremote}{botname}$/i && $text =~ m!$Regex{sharetheremote}{announce}!) {
		print "*Detected STR announce: $1 - $2 - $3 - $4 - $5 - $6 - $7 - $8 - $9";
		$Reports{sharetheremote}{seen}++;
		my %release = (uploader => $1, title => $2, season => $3, episode => $4, source => $5, format => $6, quality => $7);
		my($groupID, $torrentID) = ($8, $9);
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'sharetheremote' || !$Filters{$out}{active}) { next OUT; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			$Reports{sharetheremote}{downloaded}++;
			download($out, $torrentID, $torrentDir, "sharetheremote", $out);
			return;
		}
	}
	elsif($target =~ /^$Regex{passthepopcorn}{channel}$/i && $nick =~ /^$Regex{passthepopcorn}{botname}$/i) {
		if($text =~ m!New Upload by: (.+)!) {
			$PTPrelease{uploader} = $1;
			$Reports{passthepopcorn}{seen}++;
		}
		elsif($text =~ m!Title: (.*?) Director: (.*?) Year: (\d+)!) {
			$PTPrelease{title} = $1; $PTPrelease{director} = $2; $PTPrelease{year} = $3;
		}
		elsif($text =~ m!Codec: (.*?) Container: (.*?) Source Media: (.*?) Resolution: (.+)!) {
			$PTPrelease{codec} = $1, $PTPrelease{container} = $2, $PTPrelease{source} = $3, $PTPrelease{quality} = $4;
		}
		elsif($text =~ m!Link: http://www\.passthepopcorn\.org\/torrents\.php\?id=(\d+)&torrentid=(\d+)!) {
			print "*Detected PTP announce: $PTPrelease{title} - $PTPrelease{director} - $PTPrelease{year} - $PTPrelease{codec} - $PTPrelease{container} - $PTPrelease{source} - $PTPrelease{quality}";
			my $torrentID = $2;
		OUT:	foreach my $out (keys %Filters) {
				if($Filters{$out}{site} ne 'passthepopcorn' || !$Filters{$out}{active}) { next; }
				print "||*Checking Filter: $out";
				foreach my $subRelease (keys %PTPrelease) {
					if(filter("not_$subRelease", $PTPrelease{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
						print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
					}
					if(filter($subRelease, $PTPrelease{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
				}
				$Reports{tehconnection}{downloaded}++;
				download($out, $torrentID, $torrentDir, "passthepopcorn", $out);
			}
			%PTPrelease = ();
			return;
		}
	}
	elsif($target =~ /^$Regex{whatcd}{channel}$/i && $nick =~ /^$Regex{whatcd}{botname}$/i && $text =~ m!$Regex{whatcd}{announce}!) {
		open OUTPUT, ">>WHATautoStats" or die $!;
		$Reports{whatcd}{seen}++;
		#Assign the values pulled from the regex
		my ($log, $logPercent, $cue, $scene, $torrentID, $downloadID, $tags) = ($8, $9, $10, $12, $13, $14, $15);
		my %release = (artist => $1, album => $2, year => $3, format => $4, quality => $5, source => $11);
		#Making all tags in releases uniform
		$tags =~ s/ |, /,/g; $tags =~ s/,/, /g; $tags =~ s/_/./g;
		my @tags = split(/, /, $tags);
		print OUTPUT "$release{artist}, $release{album}, $release{year}, $release{format}, $release{quality}, @tags\n";
		close OUTPUT;
		my $string = "*Detected What.CD announce: $release{artist} - $release{album} \[$release{year}\] - $release{format} / $release{quality}";
		if ($log) {
			$string .= " / Log";
		}
		if ($logPercent) {
			$string .= " / $logPercent";
		}
		if ($cue) {
			$string .= " / Cue";
		}
		print "$string / $release{source} - @tags";
		#Check each filter for matches in format, quality, source, year, and artist.
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{site} ne 'whatcd' || $Filters{$out}{filterType} ne 'music' || !$Filters{$out}{active}) { next OUT; }
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
				#Check FLAC for log, skip any other kind of release
			if ($Filters{$out}{log} && $release{format} =~ /FLAC/i && !$log) {
				print "||04Didn't detect match in log: 08log not present04, aborting";
				print "||-----------------------";
				next OUT;
			} elsif ($Filters{$out}{log} && $log) {
				print "||02Detected match in log: log present";
				if ($Filters{$out}{logPer} && $Filters{$out}{logPer} > $logPercent)  {
					print "||04Didn't detect match in log percentage: $logPercent";
					print "||-----------------------";
					next OUT;
				} elsif ($Filters{$out}{logPer} && $Filters{$out}{logPer} <= $logPercent) {
					print "||02Detected match in log percentage: $logPercent";
				}
			}

			#Check FLAC for cue, skip any other kind of release
			if($Filters{$out}{cue} && $release{format} =~ /FLAC/i && !$cue)  {
				print "||04Didn't detect match in cue: 08cue not present04, aborting";
				next OUT;
			} elsif($Filters{$out}{cue} && $cue) {
				print "||02Detected match in cue: cue present";
			}
			#Check scene flag
			if($Filters{$out}{scene} && !$scene) {
				print "||04Didn't detect match in scene: 08scene not present04, aborting";
				print "||-----------------------";
				next OUT;
			} elsif($Filters{$out}{scene} && $scene)  {
				print "||02Detected match in scene:04 $scene";
			}

			#checking tags to _not_ download
			if($Filters{$out}{not_tags}) {
				my $thing = $Filters{$out}{not_tags};
				foreach my $filter(@$thing) {
					if($filter ~~ @tags) { print "||04Negative Tag Filters Matched in tags, aborting:08 $filter"; print "||-----------------------"; next OUT; }
				}
				print "||02Negative Tag Filters Passed, continuing";
			}
			#checking required tags to download
			if($Filters{$out}{all_tags}) {
				my $thing = $Filters{$out}{all_tags};
				foreach my $filter(@$thing) {
					if(!($filter ~~ @tags)) { print "||04Mandatory Tag Filters not Matched in tags, aborting:08 $filter"; print "||-----------------------"; next OUT; }
				}
				print "||02Mandatory Tag Filters Passed, continuing";
			}
			#checking tags _to_ download
			if($Filters{$out}{tags}) {
				my $thing = $Filters{$out}{tags};
				foreach my $filter(@$thing) {
					if($filter ~~ @tags) {
						print "||02Detected match in tags: $filter";
						$Reports{whatcd}{downloaded}++;
						download($out, $downloadID, $torrentDir, "whatcd", $out);
						return;
					}
				}
				print "||04Didn't detect match in tags: @tags, aborting";
				print "||-----------------------";
				next OUT;
			}
			else {
				print "||02Tag Filter not defined, continuing";
				$Reports{whatcd}{downloaded}++;
				download($out, $downloadID, $torrentDir, "whatcd", $out);
				return;
			}
		}
	}
	elsif($target =~ /^$Regex{whatcd}{channel}$/i && $nick =~ /^$Regex{whatcd}{botname}$/i && $text =~ m!$Regex{whatcd}{announce2}!) {
		my %release = (title => $1);
		my ($torrentID, $downloadID, $tags) = ($2, $3, $4);
		$tags =~ s/ |, /,/g; $tags =~ s/,/, /g; $tags =~ s/_/./g;
		my @tags = split(/, /, $tags);
		print "Detected What.CD e-book/comic/software announce: $release{title} - @tags";
	OUT:	foreach my $out (keys %Filters) {
			if($Filters{$out}{filterType} ne 'ebook' || $Filters{$out}{site} ne 'whatcd' || !$Filters{$out}{active}) { next OUT; }
			$Reports{whatcd}{seen}++;
			print "||*Checking Filter: $out";
			foreach my $subRelease (keys %release) {
				if(filter("not_$subRelease", $release{$subRelease}, $Filters{$out}{"not_$subRelease"}, 0)) {
					print "||04Negative Filters Matched, aborting"; print "||-----------------------"; next OUT;
				}
				if(!filter($subRelease, $release{$subRelease}, $Filters{$out}{$subRelease}, 1)) { next OUT; }
			}
			#checking tags to _not_ download
			if($Filters{$out}{not_tags}) {
				my $thing = $Filters{$out}{not_tags};
				foreach my $filter(@$thing) {
					if($filter ~~ @tags) { print "||04Negative Filters Matched in tags, aborting: $filter"; print "||-----------------------"; next OUT; }
				}
				print "||02Negative Filters Passed, continuing";
			}
			#checking required tags to download
			if($Filters{$out}{all_tags}) {
				my $thing = $Filters{$out}{all_tags};
				foreach my $filter(@$thing) {
					if(!($filter ~~ @tags)) { print "||04Mandatory Filters not Matched in tags, aborting: $filter"; print "||-----------------------"; next OUT; }
				}
				print "||02Mandatory Filters Passed, continuing";
			}
			#checking tags _to_ download
			if($Filters{$out}{tags}) {
				my $thing = $Filters{$out}{tags};
				foreach my $filter1(@$thing) {
					if($filter1 ~~ @tags) {
						print "||02Detected match in tags: @tags";
						$Reports{whatcd}{downloaded}++;
						download($out, $downloadID, $torrentDir, "whatcd", $out);
						return;
					}
				}
				print "||04Didn't detect match in tags: @tags";
				print "||-----------------------";
				next;
			}
			else {
				print "||02Tag Filter not defined: @tags";
				$Reports{whatcd}{downloaded}++;
				download($out, $downloadID, $torrentDir, "whatcd", $out);
				return;
			}
		}
	}
	elsif($target =~ /#whatbot/i && $nick eq 'mlapaglia' && $text eq 'whatbots, TRANSFORM!') {
		$data->command("msg $target transforms into mn!");
	}
	#####################
	#IRC LISTEN COMMANDS#
	#####################
	else {
		#If private message, $target contains our nick, so we
		#change $target to $nick in order to reply via PM
		if (!$data->ischannel($target)) { $target = $nick; }

		#Decide the authorization required whether message is through channel or PM
		if(($target ~~ @chanFilter && $address ~~ @nickOwner) || ($target eq $nick && $address ~~ @nickOwner)) {
			#####################
			##DOWNLOAD COMMANDS##
			#####################
			if($text =~ /^%download (.*) (\d+)/i) {
				my $torrentID = $2;
				if(checkSpace($data) != 1) { return; }
				if($torrentID > 1000000000) { $data->command("msg $target Trying to crash me now, eh?") }
				$data->command("msg $target Downloading $torrentID from $1 now");
				if($1 =~ /^WAFFLES/i) 		{ downloadWAFFLES(0, $torrentID, $torrentDir, $data, $target); }
				elsif($1 =~ /^WHAT/i) 		{ download(0, $torrentID, $torrentDir, "whatcd", 0, $data, $target); }
				elsif($1 =~ /^TC/i) 		{ download(0, $torrentID, $torrentDir, "tehconnection", 0, $data, $target); }
				elsif($1 =~ /^LIBBLE/i) 	{ download(0, $torrentID, $torrentDir, "libble", 0, $data, $target); }
				elsif($1 =~ /^STR/i) 		{ download(0, $torrentID, $torrentDir, "sharetheremote", 0, $data, $target); }
				elsif($1 =~ /^PTP/i) 		{ download(0, $torrentID, $torrentDir, "passthepopcorn", 0, $data, $target); }
				elsif($1 =~ /^BTN/i) 		{ download(0, $torrentID, $torrentDir, "broadcasthenet", 0, $data, $target); }
				elsif($1 =~ /^WUNZA/i)		{ download(0, $torrentID, $torrentDir, "wunza", 0, $data, $target); }
				elsif($1 =~ /^STMUSIC/i) 	{ download(0, $torrentID, $torrentDir, "stmusic", 0, $data, $target); }
				elsif($1 =~ /^SCC/i) 		{ download(0, $torrentID, $torrentDir, "sceneaccess", 0, $data, $target); }
				elsif($1 =~ /^HDBITS/i)		{ download(0, $torrentID, $torrentDir, "hdbits", 0, $data, $target);}
				elsif($1 =~ /^X264/i) 		{ download(0, $torrentID, $torrentDir, "x264", 0, $data, $target); }
				elsif($1 =~ /^REVTT/i) 		{ download(0, $torrentID, $torrentDir, "revolutiontt", 0, $data, $target); }
				elsif($1 =~ /^GOEM/i) 		{ download(0, $torrentID, $torrentDir, "goem", 0, $data, $target); }
				elsif($1 =~ /^SDBITS/i) 	{ download(0, $torrentID, $torrentDir, "sdbits", 0, $data, $target); }
				elsif($1 =~ /^BITHDTV/i) 	{ download(0, $torrentID, $torrentDir, "bithdtv", 0, $data, $target); }
				elsif($1 =~ /^TD/i) 		{ download(0, $torrentID, $torrentDir, "torrentdamage", 0, $data, $target); }
				elsif($1 =~ /^PTN/i) 		{ download(0, $torrentID, $torrentDir, "piratethenet", 0, $data, $target); }
				elsif($1 =~ /^DH/i) 		{ download(0, $torrentID, $torrentDir, "digitalhive", 0, $data, $target); }
				elsif($1 =~ /^PTM/i)		{ download(0, $torrentID, $torrentDir, "pretome", 0, $data, $target); }
				elsif($1 =~ /^PIN/i)		{ download(0, $torrentID, $torrentDir, "packmein", 0, $data, $target); }
				elsif($1 =~ /^ST/i)		{ download(0, $torrentID, $torrentDir, "supertorrents", 0, $data, $target); }
				elsif($1 =~ /^MV/i)		{ download(0, $torrentID, $torrentDir, "musicvid", 0, $data, $target); }
				elsif($1 =~ /^SCC/i)		{ download(0, $torrentID, $torrentDir, "sceneaccess", 0, $data, $target); }
				elsif($1 =~ /^BMTV/i)		{ download(0, $torrentID, $torrentDir, "bitmetv", 0, $data, $target); }
				elsif($1 =~ /^BITME/i)		{ download(0, $torrentID, $torrentDir, "bitme", 0, $data, $target); }
				elsif($1 =~ /^IPT/i)		{ download(0, $torrentID, $torrentDir, "iptorrents", 0, $data, $target); }
				elsif($1 =~ /^TL/i)		{ download(0, $torrentID, $torrentDir, "torrentleech", 0, $data, $target); }
				elsif($1 =~ /^DB9/i)		{ download(0, $torrentID, $torrentDir, "deepbassnine", 0, $data, $target); }
				elsif($1 =~ /^NT/i)		{ download(0, $torrentID, $torrentDir, "ntorrents", 0, $data, $target); }
				elsif($1 =~ /^AHD/i)		{ download(0, $torrentID, $torrentDir, "awesomehd", 0, $data, $target); }
			}
			#####################
			####ADMIN COMMANDS###
			#####################
			elsif($text =~ /^%filter (.*)/i) {
				if($1 =~ /^disable (.*)/i) {
					if($Filters{$1}) { $Filters{$1}{active} = 0; $data->command("msg $target $1 filter disabled"); }
					else { $data->command("msg $target $1 filter doesn't exist"); }
				}
				elsif($1 =~ /^enable (.*)/i) {
					if($Filters{$1}) { $Filters{$1}{active} = 1; $data->command("msg $target $1 filter enabled"); }
					else { $data->command("msg $target $1 filter doesn't exist"); }
				}
				else { $data->command("msg $target %filter [disable|enable] [filterName] [1|0]"); return; }
				tied(%Filters)->WriteConfig("$ENV{HOME}/WHATauto/filters.conf");
			}
			#####################
			###GENERAL COMMANDS##
			#####################
			elsif($text =~ /^%reload/i && loadConfigs()) { $data->command("msg $target Filters reloaded"); }

			elsif($text =~ /^%statsreset/i) {
				foreach my $out (keys %Reports) {
					$Reports{$out}{seen} = 0;
					$Reports{$out}{downloaded} = 0;
				}
				tied(%Reports)->WriteConfig("$ENV{HOME}/WHATauto/reports.conf");
				$data->command("msg $target Stats cleared");
			}

			elsif($text =~ /^%stats/i) {
				foreach my $out (keys %Reports) {
					if($Reports{$out}{seen} != 0) {
						my $string = sprintf '%-16s%s', $out;
						$string .= sprintf '%-12s%s', "seen: $Reports{$out}{seen}";
						$string .= "downloaded: $Reports{$out}{downloaded}";
						$data->command("msg $target $string");
					}
				}
			}

			elsif($text =~ /^%time/i) {
				my $time = showTime();
				$data->command("msg $target *Current System Time: $time");
			}

			elsif($text =~ /^%current/i) {
				$data->command("msg $target *Current Configuration:--------------");
				foreach my $out (keys %Filters) {
					$data->command("msg $target $Filters{$out}{site} : $out");
					foreach my $service (sort (keys %{$Filters{$out}})) {
						if($service ne 'site') {
							if(ref $Filters{$out}{$service} eq 'ARRAY') {
								$data->command("msg $target $service: @{$Filters{$out}{$service}}");
							} else {
								$data->command("msg $target $service: $Filters{$out}{$service}");
							}
						}
					}
					$data->command("msg $target -------------------------------------");
				}
			}

			elsif($text =~ /^%free/i) {
				my ($avail, $free) = showFree();
				$data->command("msg $target **Free Space on $drive: $avail GB ($free %)");
			}

			elsif($text =~ /^%version/i) { $data->command("msg $target WHATauto - version $VERSION by mlapaglia & gravey"); }

			elsif($text =~ /^%help/i) {
				$data->command("msg $target WHATauto - a Multi-purpose IRSSI download script");
				$data->command("msg $target %download help | %filter help | %reload | %statsreset");
				$data->command("msg $target Other commands: %stats %current %time %free %join %part");
			}

			elsif($text =~ /^%join #(.*)/i) { $data->command("JOIN #$1"); }

			elsif($text =~ /^%part #(.*)/i) { $data->command("PART #$1"); }
		}
	}
}
###############
#Returns the current date and time properly formatted.
sub showTime {
	my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
	my @weekDays = qw(Sun Mon Tue Wed Thu Fri Sat Sun);
	my ($second, $minute, $hour, $dayOfMonth, $month, $yearOffset, $dayOfWeek, $dayOfYear, $daylightSavings) = localtime();
	my $year = 1900 + $yearOffset;
	my $theTime = "$hour:$minute:$second, $weekDays[$dayOfWeek] $months[$month] $dayOfMonth, $year";
	return $theTime;
}
###############
#Returns the amount and percentage of disk space remaining
sub showFree {
	my $ref = df("$drive");
	my $used = $ref->{used};
	my $avail = $ref->{bavail};
	my $free = sprintf("%.2f",$avail / ($avail+$used) * 100);
	$avail = sprintf("%.2f",$avail / 1024000);
	return($avail, $free);
}
###############
#Warns about low disk space via text message
sub checkSpace {
	my $data = shift;
	my ($avail, $free) = showFree();
	if ($free < $freePercent) {
		print "***Server space at $free%***";
		$data->command("msg $Credentials{whatcd}{username} ***SERVER SPACE AT $free%***DOWNLOADING HALTED***");
		return 0;
	}
	else { return 1; }
}
###############
#Load Filters
sub loadConfigs {
	tie %Reports,     'Config::IniFiles', (-file => "$ENV{HOME}/WHATauto/reports.conf");	 Irssi::print ("*reports.conf...... loaded");
	tie %Credentials, 'Config::IniFiles', (-file => "$ENV{HOME}/WHATauto/credentials.conf"); Irssi::print ("*credentials.conf.. loaded");
	tie %Regex,       'Config::IniFiles', (-file => "$ENV{HOME}/WHATauto/regex.conf");	 Irssi::print ("*regex.conf........ loaded");
	tie %Filters,     'Config::IniFiles', (-file => "$ENV{HOME}/WHATauto/filters.conf");	 Irssi::print ("*filters.conf...... loaded");
	tie %Setup,       'Config::IniFiles', (-file => "$ENV{HOME}/WHATauto/setup.conf");	 Irssi::print ("*setup.conf........ loaded");
	return 1;
}
###############
#Loop through each filter, looking for the given item. If
#item is found, return true. If not, return false.
sub filter {
	my ($name, $item, $filter, $pos) = @_;
	if (!$filter) {
		if($pos) { return 1; }
		else { return 0; }
	}
	if(ref $filter eq 'ARRAY') {
		foreach (@$filter) {
			if($item eq $_ || $item ~~ /^$_$/i) {
				if($pos) { print "||02Detected match in $name: 09", $_, "02, continuing"; }
				else { print "||04Detected match in $name: 09", $_, "02, aborting"; }
				return 1;
			}
		}
	} else {
		if($item eq $filter || $item ~~ /^$filter$/i) {
			if($pos) { print "||02Detected match in $name: 09", $item, "02, continuing"; }
			else { print "||04Detected match in $name: 09", $item, "04, aborting"; }
			return 1;
		}
	}
	if($pos) {
		print "||04Didn't detect match in $name: 08", $item, "04, aborting";
		print "||-----------------------";
	} else { print "||02Didn't detect match in $name: 09", $item, "02, continuing"; }
	return 0;
}
###############
#automatically leaves channel if it's an official channel (no bots allowed)
sub chanBlock {
	my ($channel, $server) = @_;
	my @chanBlocks = ("#what.cd", "#what.cd-help", "#pu+", "#tm+", "#elite");

	foreach (@chanBlocks) {
		if ($_ eq $channel) {
			Irssi::print("*** WARNING: Bots are not allowed in $channel.  Now leaving...");
			$server->command("PART $channel");
		}
	}
}
###############
#Download subroutine for WAFFLES
sub downloadWAFFLES {
	my ($isAuto, $downloadID, $torrentDir, $server, $target) = @_;
	my $mech = WWW::Mechanize->new( autocheck => 1, cookie_jar => { file => "$cookies", autosave => 1, ignore_discard => 1 } );
	#login to site
	$mech->get("https://www.waffles.fm");
	if($mech->content =~ /The place to share, cook, and enjoy recipes/i) {
		print "No $cookies file found or valid waffles cookie present, attempting login";
		$mech->get("https://www.waffles.fm/w/index.php?title=Special:UserLogin&returnto=Main_Page");
		$mech->untick("ipLogout", 1);
		$mech->submit_form( form_number => 0,fields => { wpName => $Credentials{waffles}{username}, wpPassword => $Credentials{waffles}{password}, } );
	}
	$mech->get("https://www.waffles.fm/details.php?id=$downloadID");
	#actual download command
	if(my $link = $mech->find_link(url_regex => qr/(download\.php.+uid=\d+)/)) {
		$mech->get($link);
		my $name = $link->text();
		if(-e "$torrentDir/$name") { if($server) { $server->command( "msg $target **$name already exists."); } }
		else {
			$mech->save_content("$torrentDir/$name");
			if($server) { $server->command( "msg $target **$name downloaded successfully." ); }
			print "**$name downloaded successfully.";
			print "-------------------------------------";
		}
	}
	else {
		if($server) { $server->command( "msg $target **$downloadID does not exist on Waffles.fm**." ); }
		print "**$downloadID download FAILED**";
		print "-------------------------------------";
	}
}
###############
#Download subroutine for all sites
sub download {
	my ($isAuto, $downloadID, $directory, $site, $filter, $server, $target) = @_;
	my $mech = WWW::Mechanize::GZip->new( autocheck => 1, cookie_jar => { file => "$cookies", autosave => 1, ignore_discard => 1 } );
	my $link = $Regex{$site}{detailsPage} . $downloadID;
	my $response = $mech->get("$link");
	#If login is required, do so
	if($mech->title eq $Regex{$site}{loginTitle}) {
		print "No $cookies file found or valid $site cookie present, attempting login";
		my $formNum = 0;
		if($Regex{$site}{loginFormID}) {
			$formNum = $Regex{$site}{loginFormID};
		}
		if($Regex{$site}{stayLoggedIn}) {
			$mech->tick($Regex{$site}{stayLoggedIn} => $Regex{$site}{stayLoggedInTick});
		}
		if(!$Regex{$site}{loginName} || !$Regex{$site}{password}) {
			print "||**MISSING LOGIN NAME OR PASSWORD FOR $site, check credentials.conf, EXITING"; return;
		}
		if(!$mech->form_number($formNum)) {
			print "||**NO LOGIN FORM AVAILABLE, EXITING"; return;
		}
		$mech->submit_form( form_number => $formNum, fields => { $Regex{$site}{loginName} => "$Credentials{$site}{username}", $Regex{$site}{loginPass} => "$Credentials{$site}{password}" } );
		$response = $mech->get("$link");
		if($mech->title eq $Regex{$site}{loginTitle}) {
			print "||**LOGIN FAILED, check username/password in credentials.conf"; return;
		}
	}
	my $file;
	#if there is a linkRegex, this is a non-gazelle site
	if($Regex{$site}{linkRegex} && $mech->find_link(url_regex => qr/$Regex{$site}{linkRegex}/)) {
		my $link = $mech->find_link(url_regex => qr/$Regex{$site}{linkRegex}/);
		$mech->get($link);
	    	$file = $link->text();
	#if there is a content-disposition, this is a gazelle site
	} elsif (my $disposition = $response->{_headers}->{"content-disposition"}) {
		$disposition =~ /$Regex{$site}{contentDisposition}/;
		$file = $1;
	#if both failed something is wrong
	} else {
		if($server) { $server->command( "msg $target **$downloadID does not exist on $site**" ); }
		print "||02**$downloadID download FAILED**";
		print "||-------------------------------------";
		return;
	}
	$file = uri_unescape(decode_entities($file));
	if($isAuto) {
		sleep 8;
		#if download is automatic, check for filter directory overload
		if($Filters{$isAuto}{torrentDir} ne "") {
			print "||Changing directory to $Filters{$isAuto}{torrentDir}"; $directory = $Filters{$isAuto}{torrentDir};
		}
	}
	#if download isn't automatic, check for filter directory override
	elsif($Credentials{$site}{torrentDir} ne "") {
		$directory = $Credentials{$site}{torrentDir};
	}
	if(-e "$directory/$file") {
		if($server) {
			$server->command( "msg $target **$file already exists."); return;
			print "||02**$file already exists.";
			print "||-------------------------------------";
		}
	}
	$mech->save_content("$directory/$file");
	if($server) {
		$server->command( "msg $target **$file downloaded successfully.");
	}
	if($filter && $Filters{$filter}{notify}) {
		email("$file downloaded successfully");
	}
	print "||09**$file downloaded successfully.";
	print "||-------------------------------------";
}
###############
#Notification subroutine
sub email {
	my $message = shift;
	my $mailer = new Net::SMTP::TLS(
		'smtp.gmail.com',
		Hello    => 'smtp.gmail.com',
		Port     => 587,
		User     => $Setup{notification}{emailFrom},
		Password => $Setup{notification}{emailPass});

	$mailer->mail($Setup{notification}{emailFrom});
	$mailer->to($Setup{notification}{emailTo});

	$mailer->data();
	$mailer->datasend("From: $Setup{notification}{emailFrom}". "\n");
	$mailer->datasend("To: $Setup{notification}{emailTo}" . "\n");
	$mailer->datasend('Subject: WHATauto Notification'. "\n");
	$mailer->datasend("\n");
	$mailer->datasend($message . "\n");
	$mailer->dataend();
	$mailer->quit;
}

Irssi::signal_add("message invite", "message_invite");
Irssi::signal_add("channel joined", "channel_joined");
Irssi::signal_add("event privmsg", "event_privmsg");
